3단원 <리스트> 연습문제 풀이
임규연 (lky473736) 
2024. 05. 26.

1. 다른 건 다 맞는 설명이지만, '다'는 모순이다. 아래의 예시를 들어 설명하겠다.

아래는 1, 2, 3을 연속적으로 저장하기 위해 배열을 이용하여 저장한 예시이다.
int arr[3] = {1, 2, 3};

아래는 1, 2, 3을 연속적으로 저장하기 위해 링크드 리스트를 이용하여 저장한 예시이다. 
struct node {
    int data;
    struct node* link;
}

(1, link1) -> (2, link2) -> (3, NULL)

배열을 이용해서 1, 2, 3을 저장하면 3 * 4byte = 12byte의 기억공간을 사용한다.
링크드 리스트를 이용해서 1, 2, 3을 지정하면 한 노드마다 data, link값을 지니기 때문에 꽤나 큰 용량을 사용한다. 한 노드의 크기를 확인하는 코드는 이 디렉토리 상에 problem_1.c 파일에 있다.

2. 애초에 지금 배우고 있는 것이 리스트에 관한 것이니, 희소행렬이 정답일 것. 리스트는 데이터가 순서를 가지고 기억장소에 연속적으로 저장되는 것을 의미한다. 희소행렬은 2차원 배열로 구현할 수 있으며, 이는 리스트를 행 갯수만큼 이어붙인 구조로 표현할 수 있을 것이다.

3. pass

4. 선형리스트의 장점과 단점을 말하자면 아래와 같다.

장점 : 1) 데이터의 연속적인 저장으로 메모리를 효율적으로 사용할 수 있음
      2) 자주 변하지 않는 데이터를 보관하는 데에 적합한 구조
단점 : 1) 데이터가 자주 변경될 시 데이터 간 많은 자리 이동이 발생하여 시간이 다수 소요될 수 있음
          가. 데이터가 삽입 시 : n - k + 1
          나. 데이터가 삭제 시 : n - k
      2) 데이터 삽입 시 기억공간의 추가가 필요할 수 있음

5. 
<삽입 알고리즘>
    1) 삽입할 위치로부터 그 뒤의 데이터를 한 칸씩 뒤로 push
        - 만약 행렬의 크기가 부족하다면
            - overflow, system down
        - 아니라면
            - 이어서 진행
    2) push가 완료되었다면 지정된 위치에 데이터 삽입함

<삭제 알고리즘>
    1) 삭제할 위치의 데이터에 0 대입
    2) 삭제된 데이터 위치로부터 그 뒤의 데이터를 한 칸씩 pull

6. 연결리스트는 data field와 link field를 가지고 있어서 다음에 처리할 데이터의 주소를 가지고 있는 리스트이다. 이때 각각의 node들은 비연속적으로 저장되어 있다. 장점으로는 기억장소에 비연속적으로 저장할 수 있기 때문에 overflow나 빈번한 이동 연산을 줄일 수 있다. 하지만 단점은, 만약 연결리스트가 중간에 link값이 비어있다면 다음 연결리스트를 찾을 수 없게 된다. 

- 단순 연결리스트 : node에 data, link가 있어서 node를 순회하면서 데이터를 catch
- 환형 연결리스트 : 단순 연결리스트의 마지막 node의 link값이 가장 첫번째 node를 가리키고 있음. 하지만 이러면 시작 위치를 분명히 확정지을 수 없다는 단점이 있음.
- 이중 연결리스트 : node에 data, llink, rlink가 있어서 node를 한 방향이 아닌 두 개의 방향으로 순회 가능
- 이중 환형 연결리스트 : 이중 연결리스트 + 환형 연결리스트가

7~13. pass