2단원 <추상 데이터 타입과 배열> 연습문제 풀이
임규연 (lky473736) 
2024. 05. 25.

1. 데이터 추상화란 데이터의 명세 (description)와 구현 (implementation)을 구분하기 위한 목적으로, 데이터의 대표성을 나타내지 않는 세부사항을 감추고 대표 사항만 드러내는 것을 의미한다. 추상화라는 개념 자체가 특정 기능의 세부 기능을 사용자에게 보이지 않도록 하는 것이기에 특정 정보를 은닉하였을 가능성이 있다. 데이터 추상화의 예시로는 특정 수의 덧셈, 뺄셈 등인데, 이들의 원리와 비트 연산을 개발자 입장에서는 알 필요가 없다. 

2. 연산자 추상화가 위의 예시이다. 덧셈을 구현하는 데에 + 기호를 사용하면 그만이지, +의 원리, 비트마스킹, 전가산기와 반가산기 원리 등을 개발자가 고려할 필요는 없는 것이다.

3. 희소행렬은 sparse matrix라고 명하며, 실제 정보가 적은 2차원 배열을 의미한다. 실제 정보가 없이 나머지 영역은 전부 0으로 채워져 있기 때문에 메모리 낭비가 심하다. 따라서 희소행렬을 표현하는 데에 실제 형상을 갖춘 데이터의 위치를 사용하게 된다. 희소행렬에서 존재하는 실제 데이터의 수를 N이라 한다면, 희소행렬의 간소화 행렬은 [N+1][3]의 크기를 지닌다.

4. 전치행렬은 transpose matrix라고 명하며, 이는 행과 열의 index를 뒤집은 행렬이다. 예를 들어서, {{1, 2}, {3, 4}}라는 행렬을 transport하면 {{1, 3}, {2, 4}}가 된다. 가장 큰 특징은, diagonal을 축으로 하여 회전한 형태라고 생각하면 된다. 희소행렬이 표현된 배열을 전치행렬로 변환하려면 그냥 diagonal을 기준으로 두 위치를 변경해주면 된다. 소스코드는 같은 디렉토리에 파일로 구현한다.

5. 배열은 기억장소에 연이어 하나의 블록 형태로 저장되고, row-oriented 형식을 지향하며, 한 행렬의 component들은 같은 타입을 지닌다. 또한 배열은 각 원소와 index를 mapping한다. 배열의 논리적 구조는 n차원으로 구성되지만, 실제적으로 물리적 구조로써는 주메모리에 저장되기 때문에 1차원의 선형적인 구조에 원소를 주소와 대응하여 저장하는 방식을 취하게 된다.

6. 원래는 c언어는 행 우선이기 때문에 2차원 배열의 크기를 (i, j)라고 하고 특정 위치가 (p, q)라고 할 때, j * p + q로 location을 구할 수 있었다. 하지만 만약 열 우선이라고 가정하면, 그냥 p랑 q 위치를 변경하면 되는 것 아니겠는가? 따라서 정답은 j * q + p이다.

7. 3차원 배열의 크기를 (i, j, k)라고 하고, 특정 위치가 (p, q, r)이었다면 원래의 행 우선 location은 p * j * k + q * k + r이었다. 만약에 열 우선으로 변경되었으면 그냥 (r, q, p)로 또 바꾸면 될 것 같다. 따라서 열 우선 location은 r * j * k + q * k + p이다.

8. pass

9. 아래와 같이 구현하면 될 것이다. 2중 포인터를 사용하면 된다.

int **arr;
arr = (int**) malloc (sizeof(int*) * (row));
    
for (int i = 0; i < row; i++){
    arr[i] = (int*) malloc (sizeof(int) * col);
}